flyweight for bullets
state machine for enemy phases

always have a default spritesheet loaded

Documentation to put in the editor somewhere:
-When an enemy is killed, all bullets attached to it will despawn
-Sprite names cannot contain the characters '[' ']'
-No two sprite/animation can have the same name
-Idle/movement animatables can be sprites, but attack animatable must be an animation

Notes for me:
-The mainEMP of an attack is always spawned at the exact same time of an attack; spawnType's time is ignored
-Remember to call animatableSetComponent.changeState on player when it attacks
-All sf::Sprite pointers in all Animations point to the same sf::Sprite object (if same name), so sf::Sprites from Animations must never be
 modified, since it will change all other Animations. On the other hand, all sf::Sprite pointers in each SpriteComponent point to unique sf::Sprite
 objects, so the sf::Sprite pointer in SpriteEffectAnimation MUST point to a SpriteComponent's pointer (so when setting SpriteEffectAnimation, 
 spriteComponent.getSprite() must be used) so that other sf::Sprites are not affected.

CURRENT TODO:
death animation by making new entity
death animation is a DeathAction; DeathAnimationDeathAction choices:
	-Play animatable (if sprite, specify duration)
	-Shrink (sprite shrinks into nothing; specify duration)
	-FadeAway (specify duration)
	
	
TODO:
-Despawn time on enemies
-Power up tiers for player; each has its own animatableset
-item drops (see math notes)
-Bezier movablepoint
-Make entity positions be their sprite's center
-Multiple small shockwave effects 
-mandatory death effect for each enemy: user chooses a SpriteEffectAnimation (FadeAway, RedFadeAway (tint red + fade away), ...)
-when an enemy dies, create new entity to play the death animation+effect; if no animation, just do the effect
-animations
	-optional death animation (must be standard animation)
	-//no two sprite/animation can have the same name
	-use a state machine in SpriteComponent that restarts an animation only if state is changed from attack to attack (only attack anim can be interrupted
	by another attack anim)
	-keep track of last known pos of an entity in a map in rendersystem; listener for entity deletion -> delete map entry; use this map to see if an entity
	is moving to update its SpriteComponent's state machine
	-sprites/anims have 3 options: rotate with angle of movement, lock rotation, lock rotation and face direction of movement
		-third option means if entity is moving left, all sprites/anims are mirrored across middle y-axis but do not rotate
-Add to EMP: OnContactAction: TurnIntangible (remove HitboxComponent), DestroyBulletAndAttachedChildren (give children DespawnComponent to this EMP when they spawn),
	DestroyBulletOnly (remove Sprite and Hitbox)
-DeathActionComponent (for player + enemies + bullets): does a list of DeathActions: ExecuteAttack (enemies only), ParticleExplosion, PlaySound


Entity executes attack --> all soundEffectNames added to a queue in entity's SoundComponent
Entity with EMPActionManagerComponent is spawned
	vector<pair<float, EMP*>> spawnTargets = {mainEMP} // time : EMP
	int attachedEntity = entity_that_executed_the_attack
EMPActionSystem calls update on every EMPActionManagerComponent
Entity with the MPActionManagerComponent (call it A) spawns one of its spawnTargets according to its spawnType
	--> if attachedEntity has an EnemyComponent, make sure the attachedEntity still exists first
	--> create an entity (call it B) from the spawnTarget with EMPActionManagerComponent: spawnTargets = {all of B's children}, attachedEntity = A
	--> give B HitboxComponent, SpriteComponent, MovementPathComponent
	--> if attachedEntity has EnemyComponent, give B EnemyBulletComponent; if has PlayerComponent, give B PlayerBulletComponent
	--> if using the editor, also give it EditorEnemyBulletComponent if is EnemyBullet


// ------------------------------------------------------------------------------------------------------------------------------------------------
editable = attack/attack pattern/emp/enemy/enemyphase/player
id-editable = attack/attack pattern/enemy/enemyphase
one big editor instead of multiple things for each editable

when simulating (testing) in the editor, 
give all entites an Editor(EnemyBullet/Enemy/Player)Component that has the ids of the Editor______ objects so that
user can click on a bullet/enemy and view the attack/attackpattern/emp/enemy/enemyphase/player it belongs to

click entity --> opens up windows/tabs/whatever for all the Editor_____ components it has; ie:
Click enemy bullet --> open Attack, AttackPattern, Enemy, EnemyPhase
Click enemy --> open Attack, AttackPattern, Enemy, EnemyPhase
Click player --> open Player

When making changes to and then saving an editable that is used by multiple other editables one layer up
(enemy > enemy phase; enemy > attack pattern; attack pattern > attack), ask user to confirm before saving ("this change will affect multiple other enemies/attack patterns")

every editable is local only to the level pack
user can load a different level pack and choose which id-editables to import
// ------------------------------------------------------------------------------------------------------------------------------------------------


Move custom = player chooses the MP to use and manually defines the relevant TFVs
TODO: find some way of loading and saving TFVs and MPs such that no duplicate ones are created
eg if there are 500 sub-MPs with 1 MP as reference, make sure there won't be 500*500 MPs created

MP = movable point
global position = position ignoring all references

// ------------------------------------------------------------------------------------------------------------------------------------------------
Sprite sheet editor:
1. User creates a new sprite sheet and gives it a name
2. User loads an image associated with that sprite sheet
3. User can select rectangles in the image to be saved as textures in the sprite sheet meta file. User can specify color and sprite size of the texture.

Todo: make sure sprite sheet name is a valid file name
Note: the sprite sheet name is the meta file's name, but the sprite sheet image's name can be anything. It doesn't necessarily have to be the same
as the sprite sheet name.
// ------------------------------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------------------------------------
Level editor:
1. User populates a list of enemies to spawn and their spawn locations (see Main MP spawn locations under Attack editor)
// ------------------------------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------------------------------------
Enemy editor:
1. User attaches a sprite, spritesheet, and hitbox to the enemy
2. User specifies enemy HP
3. User populates a list of enemy phases and how they activate (EnemyPhaseStartCondition)
4. User gives enemy a name --> it is saved
// ------------------------------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------------------------------------
Enemy phase editor:
1. User populates a phase with a list of attack pattern names and when they occur
2. User gives the phase a name --> it is saved
// ------------------------------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------------------------------------
Attack pattern editor:
1. User populates a list of attacks and when they will occur
2. User populates a list of MPActions (only MPActions for main MP (see Attack editor) allowed)
3. User populates a list of sound effects to be played and when
4. User gives attack pattern a name --> it is saved

Internally, all "Move" and "Stay still" MPActions are combined into a single AggregatorMP
// ------------------------------------------------------------------------------------------------------------------------------------------------

// ------------------------------------------------------------------------------------------------------------------------------------------------
Attack editor:
1. The main MP is created
2. User specifies main MP spawn location
3. User can create sub-MPs (MPs whose reference is the main MP or another sub-MP)
4. User can attach any MP to a sprite and hitbox
5. User can give any MP a list of MPActions; the main MP must have at least 1 "Move" or "Stay still at specified location" MPAction so that its lifespan is known
6. User populates a list of sound effects to be played and when
7. User gives the attack a name --> it is saved

Main MP spawn locations:
Specified global position
Specified position relative to the attack's parent (some enemy) (a StationaryMP is dropped from parent at time of attack with lifespan equal to main MP's lifespan)
Specified position relative to the attack's parent's MP (some enemy's MP) (main MP will be moving relative to parent's motion; uses EntityMP)

MPActions only if is sub-MP:
Detach from parent (user must add at least 1 "Stay still" or "Move" MPAction after a detach)
				   (in-game, after detachment, the sub-MP will be attached to an AggregatorMP containing all MPActions after the detach)
				   (there cannot be more detach actions on a sub-MP than the depth of the reference tree (number of references deep until the main MP is encountered))

MPActions for all MPs: (code for main and sub-MP are the same)
Move to a position (basically a macro for linear movement at constant speed) (exists in the GUI only)
//TODO: maybe EPA for hovering (double dampened movement along some user-defined axis) (only in GUI)
Move custom
Stay still at last position for [x] seconds (there must be at least 1 "Move" or "Stay still at specified position" action before this one)
Stay still at specified position for [x] seconds (StationaryMP)
Loop a group of actions [x] times (user specifies odd or even expansion)

MPActions for main MP or if there is a detach action before these ones:
Move to player + offset
// these 3 are GUI only
Move to specific global position
Move in direction of player + offset (user must specify a speed)
Move in direction of specific global position (user must specify a speed)

For any "Move to" action, the user can specify the TFV used for distance
OR user can choose basic options: 
	-can specify a speed (will use LinearTFV with autocalculated time to expire when MP is out of bounds)
	-can specify a time
// ------------------------------------------------------------------------------------------------------------------------------------------------
	

// ------------------------------------------------------------------------------------------------------------------------------------------------
TFV editor:
1. User chooses a concrete TFV
2. User modifies parameters
3. Show the some value vs time graph at all times
// ------------------------------------------------------------------------------------------------------------------------------------------------